<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Scavenger Hunt - Hamilton Place</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="alternate icon" href="/favicon.ico">
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-storage-compat.js"></script>
    <script src="firebase-config.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
            transition: background 0.5s ease;
        }

        body.theme-mom {
            background: linear-gradient(135deg, #e91e63 0%, #f06292 100%);
        }

        body.theme-dad {
            background: linear-gradient(135deg, #2196f3 0%, #64b5f6 100%);
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 30px 20px;
            text-align: center;
            transition: background 0.5s ease;
        }

        body.theme-mom .header {
            background: linear-gradient(135deg, #e91e63 0%, #f06292 100%);
        }

        body.theme-dad .header {
            background: linear-gradient(135deg, #2196f3 0%, #64b5f6 100%);
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.95;
        }

        .storage-status {
            font-size: 0.85em;
            margin-top: 10px;
            padding: 5px 10px;
            border-radius: 15px;
            display: inline-block;
        }

        .storage-status.error {
            background: rgba(220, 53, 69, 0.3);
            color: white;
            border: 1px solid rgba(220, 53, 69, 0.5);
        }

        .team-selector-section {
            padding: 15px 20px;
            background: rgba(255, 255, 255, 0.1);
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .team-selector-section h3 {
            color: white;
            margin-bottom: 10px;
            font-size: 1em;
        }

        .team-title-display {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .team-title-display.show {
            display: flex;
        }

        .team-title-display h2 {
            color: white;
            font-size: 2.5em;
            margin: 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            font-weight: 700;
        }

        .team-title-display.mom h2 {
            color: #e91e63;
        }

        .team-title-display.dad h2 {
            color: #2196f3;
        }

        .switch-team-btn {
            padding: 8px 20px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            border: 2px solid rgba(255, 255, 255, 1);
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .switch-team-btn:hover {
            background: rgba(255, 255, 255, 1);
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .team-selector-global {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
        }

        .team-btn-global {
            padding: 12px 25px;
            border: 3px solid white;
            background: rgba(255, 255, 255, 0.4);
            color: white;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 600;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .team-btn-global.mom {
            background: rgba(233, 30, 99, 0.5);
            border-color: rgba(233, 30, 99, 0.8);
        }

        .team-btn-global.dad {
            background: rgba(33, 150, 243, 0.5);
            border-color: rgba(33, 150, 243, 0.8);
        }

        .team-btn-global:hover {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(1.05);
        }

        .team-btn-global.mom:hover {
            background: rgba(233, 30, 99, 0.7);
        }

        .team-btn-global.dad:hover {
            background: rgba(33, 150, 243, 0.7);
        }

        .team-btn-global.active {
            background: white;
            color: #333;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .team-btn-global.mom.active {
            background: #e91e63;
            color: white;
            border-color: #e91e63;
        }

        .team-btn-global.dad.active {
            background: #2196f3;
            color: white;
            border-color: #2196f3;
        }

        .timer-section {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 2px solid #e0e0e0;
        }

        .time-input-group {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .time-input-group input {
            padding: 10px;
            border: 2px solid #6c757d;
            border-radius: 8px;
            font-size: 1em;
        }

        .btn {
            padding: 10px 20px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .btn:hover {
            background: #5a6268;
        }

        body.theme-mom .btn {
            background: #e91e63;
        }

        body.theme-mom .btn:hover {
            background: #c2185b;
        }

        body.theme-dad .btn {
            background: #2196f3;
        }

        body.theme-dad .btn:hover {
            background: #1976d2;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .countdown {
            text-align: center;
            padding: 20px;
            display: none;
        }

        .countdown.show {
            display: block;
        }

        .countdown-display {
            font-size: 3em;
            font-weight: bold;
            color: #6c757d;
            margin: 10px 0;
            transition: color 0.5s ease;
        }

        body.theme-mom .countdown-display {
            color: #e91e63;
        }

        body.theme-dad .countdown-display {
            color: #2196f3;
        }

        .countdown-label {
            font-size: 1.2em;
            color: #666;
        }

        .hunt-ended {
            text-align: center;
            padding: 20px;
            background: #d4edda;
            border: 2px solid #4CAF50;
            border-radius: 10px;
            margin: 20px;
            display: none;
        }

        .hunt-ended.show {
            display: block;
        }

        .hunt-ended h2 {
            color: #4CAF50;
            font-size: 2em;
            margin-bottom: 10px;
        }

        .scavenger-list {
            padding: 20px;
        }

        .scavenger-list h2 {
            margin-bottom: 15px;
            color: #6c757d;
            transition: color 0.5s ease;
        }

        body.theme-mom .scavenger-list h2 {
            color: #e91e63;
        }

        body.theme-dad .scavenger-list h2 {
            color: #2196f3;
        }

        .item {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 10px;
        }

        .item.finished {
            background: #e8e8e8;
            border: 2px solid #b0b0b0;
            opacity: 0.7;
        }

        .item.finished .item-title {
            text-decoration: line-through;
            color: #888;
        }

        .item.finished .item-description {
            color: #aaa;
        }

        .finished-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 3px solid #ccc;
        }

        .finished-section h2 {
            color: #888;
            font-size: 1.3em;
            margin-bottom: 15px;
        }

        .item-info {
            flex: 1;
            min-width: 200px;
        }

        .item-title {
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .item-description {
            font-size: 0.9em;
            color: #666;
        }

        .item-photos {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .photo-preview {
            width: 60px;
            height: 60px;
            border-radius: 8px;
            object-fit: cover;
            border: 2px solid #6c757d;
        }

        .photo-preview.mom {
            border-color: #e91e63;
        }

        .photo-preview.dad {
            border-color: #2196f3;
        }

        .upload-btn {
            padding: 8px 15px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background 0.3s ease;
        }

        .upload-btn:hover {
            background: #45a049;
        }

        body.theme-mom .upload-btn {
            background: #e91e63;
        }

        body.theme-mom .upload-btn:hover {
            background: #c2185b;
        }

        body.theme-dad .upload-btn {
            background: #2196f3;
        }

        body.theme-dad .upload-btn:hover {
            background: #1976d2;
        }

        .file-input {
            display: none;
        }

        .team-selector {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .team-btn {
            padding: 8px 15px;
            border: 2px solid #6c757d;
            background: white;
            color: #6c757d;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }

        .team-btn.active {
            background: #6c757d;
            color: white;
        }

        .team-btn.mom {
            border-color: #e91e63;
        }

        .team-btn.mom.active {
            background: #e91e63;
            border-color: #e91e63;
        }

        .team-btn.dad {
            border-color: #2196f3;
        }

        .team-btn.dad.active {
            background: #2196f3;
            border-color: #2196f3;
        }

        .scores-section {
            padding: 20px;
            background: #f8f9fa;
            border-top: 2px solid #e0e0e0;
            display: none;
        }

        .scores-section.show {
            display: block;
        }

        .scores-title {
            text-align: center;
            margin-bottom: 20px;
            color: #6c757d;
            transition: color 0.5s ease;
        }

        body.theme-mom .scores-title {
            color: #e91e63;
        }

        body.theme-dad .scores-title {
            color: #2196f3;
        }

        .scores-container {
            display: flex;
            justify-content: space-around;
            gap: 20px;
            flex-wrap: wrap;
        }

        .team-score {
            text-align: center;
            padding: 20px;
            background: white;
            border-radius: 15px;
            min-width: 200px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .team-score.mom {
            border: 3px solid #e91e63;
        }

        .team-score.dad {
            border: 3px solid #2196f3;
        }

        .team-score h3 {
            font-size: 1.5em;
            margin-bottom: 10px;
        }

        .team-score.mom h3 {
            color: #e91e63;
        }

        .team-score.dad h3 {
            color: #2196f3;
        }

        .score-number {
            font-size: 3em;
            font-weight: bold;
            color: #333;
        }

        .winner-celebration {
            text-align: center;
            margin-top: 30px;
            font-size: 2em;
            font-weight: bold;
            min-height: 50px;
        }

        .winner-celebration.mom {
            color: #e91e63;
        }

        .winner-celebration.dad {
            color: #2196f3;
        }

        .milkshake-message {
            text-align: center;
            margin-top: 15px;
            font-size: 1.3em;
            font-weight: 600;
            min-height: 40px;
            color: #666;
        }

        .photos-gallery {
            padding: 20px;
            display: none;
        }

        .photos-gallery.show {
            display: block;
        }

        .photos-gallery h2 {
            margin-bottom: 20px;
            color: #6c757d;
            transition: color 0.5s ease;
        }

        body.theme-mom .photos-gallery h2 {
            color: #e91e63;
        }

        body.theme-dad .photos-gallery h2 {
            color: #2196f3;
        }

        .photo-item {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .photo-item-group {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .photo-item-group-title {
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 15px;
            color: #6c757d;
        }

        .photo-item-group-photos {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .photo-item-group-photo {
            flex: 1;
            min-width: 300px;
            max-width: 500px;
        }

        .photo-item-group-photo img {
            width: 100%;
            border-radius: 8px;
            border: 3px solid;
        }

        .photo-item-group-photo.mom img {
            border-color: #e91e63;
        }

        .photo-item-group-photo.dad img {
            border-color: #2196f3;
        }

        .photo-item-group-photo-label {
            text-align: center;
            margin-top: 10px;
            font-weight: 600;
            padding: 5px 15px;
            border-radius: 20px;
            display: inline-block;
        }

        .photo-item-group-photo-label.mom {
            background: #e91e63;
            color: white;
        }

        .photo-item-group-photo-label.dad {
            background: #2196f3;
            color: white;
        }

        .photo-item-group-no-photos {
            text-align: center;
            color: #999;
            font-style: italic;
            padding: 20px;
        }

        .photo-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .photo-item-title {
            font-weight: 600;
            color: #6c757d;
        }

        .photo-item-team {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 600;
        }

        .photo-item-team.mom {
            background: #e91e63;
            color: white;
        }

        .photo-item-team.dad {
            background: #2196f3;
            color: white;
        }

        .photo-item-image {
            width: 100%;
            max-width: 500px;
            border-radius: 8px;
            display: block;
            margin: 0 auto;
        }

        @media (max-width: 600px) {
            .header h1 {
                font-size: 1.5em;
            }
            
            .countdown-display {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸ“¸ Photo Scavenger Hunt ðŸ“¸</h1>
            <p id="instructionsText">Go around and take photos with as many of the below items as you can. Each photo should be a selfie with the whole team and the item in the list. Enter the time below that everyone should be done by. At that time everybody will meet up at Red Robins. Loser buys everyone milkshakes!</p>
            <div class="storage-status error" id="storageStatus" style="display: none;"></div>
        </div>

        <div class="team-selector-section">
            <div class="team-selector-global" id="teamSelectorButtons">
                <button class="team-btn-global mom" id="teamBtnMom" onclick="selectTeamGlobal('mom')">ðŸ‘© Mom Team</button>
                <button class="team-btn-global dad" id="teamBtnDad" onclick="selectTeamGlobal('dad')">ðŸ‘¨ Dad Team</button>
            </div>
            <div class="team-title-display" id="teamTitleDisplay">
                <h2 id="teamTitleText"></h2>
                <button class="switch-team-btn" onclick="showTeamSelector()">Switch Team</button>
            </div>
        </div>

        <div class="timer-section">
            <div class="time-input-group" id="timeInputGroup">
                <label for="endTime">Hunt Ends At:</label>
                <input type="datetime-local" id="endTime" />
                <button class="btn" onclick="setEndTime()">Start Hunt</button>
            </div>
            <div class="countdown" id="countdown">
                <div class="countdown-label">Time Remaining:</div>
                <div class="countdown-display" id="countdownDisplay">00:00:00</div>
                <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 10px;">
                    <button class="btn btn-secondary" onclick="showTimeAdjust()">Adjust Time</button>
                    <button class="btn btn-danger" onclick="clearHunt()">Clear Hunt</button>
                </div>
            </div>
        </div>

        <div class="hunt-ended" id="huntEnded">
            <h2>ðŸŽ‰ Hunt is Over! ðŸŽ‰</h2>
            <p>Time to see the results!</p>
            <button class="btn btn-danger" onclick="clearHunt()" style="margin-top: 15px;">Clear Hunt</button>
        </div>

        <div class="scavenger-list" id="scavengerList">
            <h2>Find & Photograph:</h2>
            <!-- Items will be populated by JavaScript -->
        </div>

        <div class="scores-section" id="scoresSection">
            <h2 class="scores-title">Final Scores</h2>
            <div class="scores-container">
                <div class="team-score mom">
                    <h3>ðŸ‘© Mom Team</h3>
                    <div class="score-number" id="momScore">0</div>
                    <div>photos</div>
                </div>
                <div class="team-score dad">
                    <h3>ðŸ‘¨ Dad Team</h3>
                    <div class="score-number" id="dadScore">0</div>
                    <div>photos</div>
                </div>
            </div>
            <div class="winner-celebration" id="winnerCelebration"></div>
            <div class="milkshake-message" id="milkshakeMessage"></div>
        </div>

        <div class="photos-gallery" id="photosGallery">
            <h2>All Photos</h2>
            <!-- Photos will be populated by JavaScript -->
        </div>
    </div>

    <script>
        const items = [
            { id: 'mall-sign', title: 'Hamilton Place Mall Sign', description: 'The main mall entrance sign' },
            { id: 'food-court', title: 'Favorite Foodery in the Food Court', description: 'Your favorite food place in the food court' },
            { id: 'store-window', title: 'Store Window Display', description: 'An interesting store window display' },
            { id: 'restaurant-sign', title: 'Restaurant Sign', description: 'A restaurant sign' },
            { id: 'bench', title: 'Decorative Bench', description: 'A bench or seating area' },
            { id: 'flag', title: 'American Flag', description: 'An American flag flying' },
            { id: 'signage', title: 'Directional Sign', description: 'A directional or wayfinding sign' },
            { id: 'lighting', title: 'Decorative Lighting', description: 'Decorative lights or lamp posts' },
            { id: 'landscaping', title: 'Landscaping Feature', description: 'Interesting landscaping or garden area' },
            { id: 'vehicle', title: 'Unique Vehicle', description: 'An interesting or unique vehicle in parking lot' },
            { id: 'entrance', title: 'Mall Entrance', description: 'A mall entrance' },
            { id: 'ruby', title: 'Ruby the Raccoon', description: 'The stuffed raccoon hidden in Trader Joe\'s' },
            { id: 'escalator', title: 'Escalator Selfie', description: 'Take a selfie on an escalator' },
            { id: 'mall-map', title: 'Mall Directory Map', description: 'The mall directory or map display' },
            { id: 'store-logo', title: 'Favorite Store Logo', description: 'The logo or sign of your favorite store' },
            { id: 'ceiling', title: 'Interesting Ceiling Feature', description: 'Something interesting on the ceiling' },
            { id: 'floor-design', title: 'Cool Floor Design', description: 'An interesting floor pattern or design' },
            { id: 'mall-art', title: 'Mall Art or Decoration', description: 'Any art piece or decorative element in the mall' }
        ];

        let selectedTeam = 'mom';
        let endTime = null;
        let countdownInterval = null;
        let firebaseStorage = null;
        let useFirebase = false;
        let endTimeSyncInterval = null;

        // Initialize Firebase if configured
        function initFirebase() {
            console.log('Initializing Firebase...');
            console.log('firebaseConfig defined:', typeof firebaseConfig !== 'undefined');
            console.log('USE_FIREBASE:', typeof USE_FIREBASE !== 'undefined' ? USE_FIREBASE : 'undefined');
            
            if (typeof firebaseConfig !== 'undefined' && typeof USE_FIREBASE !== 'undefined' && USE_FIREBASE && firebaseConfig.apiKey !== 'YOUR_API_KEY_HERE') {
                try {
                    firebase.initializeApp(firebaseConfig);
                    firebaseStorage = firebase.storage();
                    useFirebase = true;
                    // Only show status if there's an error
                    document.getElementById('storageStatus').style.display = 'none';
                    console.log('Firebase Storage initialized successfully');
                } catch (error) {
                    console.error('Firebase initialization error:', error);
                    useFirebase = false;
                    document.getElementById('storageStatus').textContent = 'âš ï¸ Cloud Storage Error - Using Local Storage';
                    document.getElementById('storageStatus').style.display = 'inline-block';
                }
            } else {
                if (typeof firebaseConfig === 'undefined') {
                    console.warn('firebase-config.js not loaded or firebaseConfig not defined');
                } else if (typeof USE_FIREBASE === 'undefined') {
                    console.warn('USE_FIREBASE not defined in firebase-config.js');
                } else if (!USE_FIREBASE) {
                    console.log('USE_FIREBASE is set to false');
                } else if (firebaseConfig.apiKey === 'YOUR_API_KEY_HERE') {
                    console.warn('Firebase config not filled in - using template values');
                }
                console.log('Using localStorage for photo storage');
                // Only show status if there's an error
                document.getElementById('storageStatus').style.display = 'none';
            }
        }

        // Initialize
        async function init() {
            initFirebase();
            loadTeamSelection();
            
            // Load data - try Firebase first if available
            if (useFirebase && firebaseStorage) {
                // Try to load from Firebase first - this will update endTime if found
                // This MUST complete before we check localStorage
                await syncEndTimeFromFirebase();
                
                // Only check localStorage if Firebase didn't have a time
                // syncEndTimeFromFirebase already handles null and clears localStorage
                // So if endTime is still null after sync, it means Firebase was cleared or doesn't exist
                if (!endTime) {
                    const savedEndTime = localStorage.getItem('huntEndTime');
                    if (savedEndTime) {
                        const localTime = new Date(savedEndTime);
                        // Only use localStorage if it's valid and in the future
                        if (localTime && !isNaN(localTime.getTime())) {
                            endTime = localTime;
                            // Sync it back to Firebase
                            await saveEndTimeToFirebase(endTime);
                            document.getElementById('timeInputGroup').style.display = 'none';
                            if (endTime > new Date()) {
                                startCountdown();
                            } else {
                                showHuntEnded();
                            }
                        }
                    }
                }
                
                await loadPhotosFromFirebase();
                
                // Start periodic syncs
                endTimeSyncInterval = setInterval(syncEndTimeFromFirebase, 3000);
                setInterval(syncPhotosFromFirebase, 3000);
            } else {
                // Fallback to localStorage only
                await loadData();
            }
            
            renderItems();
            checkHuntStatus();
            updateInstructions();
        }

        // Sync end time from Firebase (for multi-device sync)
        async function syncEndTimeFromFirebase() {
            if (!useFirebase || !firebaseStorage) {
                console.log('Firebase not available for sync');
                return;
            }
            
            try {
                console.log('Attempting to load huntEndTime.json from Firebase Storage...');
                const endTimeRef = firebaseStorage.ref().child('huntEndTime.json');
                console.log('Firebase Storage reference created');
                
                // Try using getBytes first (avoids CORS issues) if available
                let data;
                if (typeof endTimeRef.getBytes === 'function') {
                    try {
                        const bytes = await endTimeRef.getBytes();
                        const text = new TextDecoder('utf-8').decode(bytes);
                        data = JSON.parse(text);
                        console.log('Loaded end time from Firebase using getBytes:', data);
                    } catch (bytesError) {
                        console.log('getBytes failed, trying download URL method:', bytesError);
                        // Fall through to download URL method
                    }
                }
                
                // Fallback to download URL method if getBytes not available or failed
                if (!data) {
                    try {
                        const url = await endTimeRef.getDownloadURL();
                        console.log('Download URL obtained:', url);
                        
                        // Use XMLHttpRequest instead of fetch to avoid CORS preflight
                        data = await new Promise((resolve, reject) => {
                            const xhr = new XMLHttpRequest();
                            xhr.open('GET', url, true);
                            xhr.onload = function() {
                                if (xhr.status === 200) {
                                    try {
                                        resolve(JSON.parse(xhr.responseText));
                                    } catch (e) {
                                        reject(new Error('Failed to parse JSON: ' + e.message));
                                    }
                                } else {
                                    reject(new Error(`HTTP error! status: ${xhr.status}`));
                                }
                            };
                            xhr.onerror = function() {
                                reject(new Error('Network error'));
                            };
                            xhr.send();
                        });
                        console.log('Loaded end time from Firebase using download URL:', data);
                    } catch (urlError) {
                        throw urlError;
                    }
                }
                
                // Only process if endTime exists and is not null
                if (data.endTime && data.endTime !== null) {
                    const firebaseEndTime = new Date(data.endTime);
                    // Only update if Firebase has a different time (someone else changed it) or we don't have one locally
                    if (!endTime || firebaseEndTime.getTime() !== endTime.getTime()) {
                        console.log('Updating end time from Firebase');
                        endTime = firebaseEndTime;
                        localStorage.setItem('huntEndTime', endTime.toISOString());
                        
                        // Hide time input and show countdown
                        document.getElementById('timeInputGroup').style.display = 'none';
                        
                        // Restart countdown if needed
                        if (countdownInterval) {
                            clearInterval(countdownInterval);
                        }
                        if (endTime > new Date()) {
                            startCountdown();
                            // Re-render items to show/hide upload buttons
                            renderItems();
                        } else {
                            showHuntEnded();
                        }
                    } else {
                        console.log('End time already matches Firebase');
                    }
                } else if (data.endTime === null) {
                    // Firebase has null, which means hunt was cleared - clear local state too
                    console.log('Firebase indicates hunt was cleared (endTime is null)');
                    endTime = null;
                    localStorage.removeItem('huntEndTime');
                    // Also clear photos from localStorage when hunt is cleared
                    localStorage.removeItem('huntPhotos');
                    document.getElementById('timeInputGroup').style.display = 'flex';
                    if (countdownInterval) {
                        clearInterval(countdownInterval);
                        countdownInterval = null;
                    }
                    document.getElementById('countdown').classList.remove('show');
                    document.getElementById('huntEnded').classList.remove('show');
                    document.getElementById('scoresSection').classList.remove('show');
                    document.getElementById('photosGallery').classList.remove('show');
                    document.getElementById('scavengerList').style.display = 'block';
                    renderItems();
                    updateInstructions();
                }
            } catch (error) {
                // File doesn't exist or error
                console.log('Error loading end time from Firebase:', error);
                console.log('Error details:', {
                    message: error.message,
                    code: error.code,
                    name: error.name
                });
                
                // Check if it's a CORS error
                if (error.message && error.message.includes('CORS')) {
                    console.error('CORS Error: Firebase Storage needs CORS configuration for swift-turtle.com');
                    console.error('See FIREBASE-CORS-SETUP.md for instructions');
                }
                
                // Check if it's a 404 (file doesn't exist)
                if (error.code === 'storage/object-not-found' || 
                    error.code === 'storage/404' ||
                    (error.message && (error.message.includes('404') || error.message.includes('object-not-found')))) {
                    console.log('huntEndTime.json does not exist in Firebase Storage yet - this is normal if no hunt has been started');
                    // Don't show error, just log it - this is expected on first load
                    return;
                }
                
                // If we don't have a local end time either, show the input
                if (!endTime) {
                    document.getElementById('timeInputGroup').style.display = 'flex';
                }
            }
        }

        // Load saved team selection
        function loadTeamSelection() {
            const savedTeam = localStorage.getItem('selectedTeam');
            if (savedTeam) {
                selectTeamGlobal(savedTeam, false);
            } else {
                // Show buttons if no team selected yet
                document.getElementById('teamSelectorButtons').style.display = 'flex';
                document.getElementById('teamTitleDisplay').classList.remove('show');
                document.body.className = '';
            }
        }

        // Load saved data (localStorage only - used when Firebase is not available)
        async function loadData() {
            // Only use this when Firebase is NOT available
            const savedEndTime = localStorage.getItem('huntEndTime');
            if (savedEndTime) {
                endTime = new Date(savedEndTime);
                
                // Hide time input and show countdown
                document.getElementById('timeInputGroup').style.display = 'none';
                
                if (endTime > new Date()) {
                    startCountdown();
                } else {
                    showHuntEnded();
                }
            }
        }

        // Save end time to Firebase
        async function saveEndTimeToFirebase(endTimeValue) {
            if (!useFirebase || !firebaseStorage) return;
            
            try {
                const endTimeRef = firebaseStorage.ref().child('huntEndTime.json');
                const data = { endTime: endTimeValue.toISOString() };
                const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
                await endTimeRef.put(blob);
                console.log('End time saved to Firebase');
            } catch (error) {
                console.error('Error saving end time to Firebase:', error);
            }
        }

        // Set end time
        async function setEndTime() {
            const input = document.getElementById('endTime');
            const timeValue = input.value;
            
            if (!timeValue) {
                alert('Please select an end time!');
                return;
            }

            endTime = new Date(timeValue);
            localStorage.setItem('huntEndTime', endTime.toISOString());
            
            // Save to Firebase
            await saveEndTimeToFirebase(endTime);
            
            document.getElementById('timeInputGroup').style.display = 'none';
            startCountdown();
            
            // Update instructions for active hunt
            updateInstructions();
            
            // Re-render items to show upload buttons
            renderItems();
        }

        // Show time adjust
        function showTimeAdjust() {
            document.getElementById('timeInputGroup').style.display = 'flex';
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }
            // Pre-fill the input with current end time if it exists
            if (endTime) {
                const input = document.getElementById('endTime');
                const localDateTime = new Date(endTime.getTime() - endTime.getTimezoneOffset() * 60000)
                    .toISOString()
                    .slice(0, 16);
                input.value = localDateTime;
            }
        }

        // Start countdown
        function startCountdown() {
            document.getElementById('countdown').classList.add('show');
            updateCountdown();
            countdownInterval = setInterval(updateCountdown, 1000);
        }

        // Update countdown
        function updateCountdown() {
            if (!endTime) return;

            const now = new Date();
            const diff = endTime - now;

            if (diff <= 0) {
                clearInterval(countdownInterval);
                showHuntEnded();
                return;
            }

            const hours = Math.floor(diff / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diff % (1000 * 60)) / 1000);

            const display = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            document.getElementById('countdownDisplay').textContent = display;
        }

        // Show hunt ended
        function showHuntEnded() {
            document.getElementById('huntEnded').classList.add('show');
            document.getElementById('countdown').classList.remove('show');
            document.getElementById('scoresSection').classList.add('show');
            document.getElementById('photosGallery').classList.add('show');
            // Hide the scavenger list when hunt is done
            document.getElementById('scavengerList').style.display = 'none';
            updateScores();
            renderGallery();
            updateInstructions(); // Update instructions to encourage scrolling
        }

        // Update instructions text based on hunt status
        function updateInstructions() {
            const instructionsEl = document.getElementById('instructionsText');
            const huntActive = endTime && endTime > new Date();
            const huntEnded = endTime && endTime <= new Date();
            
            if (huntEnded) {
                instructionsEl.textContent = 'ðŸŽ‰ Hunt is complete! Scroll down to see the results and find out who won! ðŸŽ‰';
            } else if (huntActive) {
                instructionsEl.textContent = 'The hunt is on! Take selfies with your whole team and the items below. Meet at Red Robins when time is up!';
            } else {
                instructionsEl.textContent = 'Go around and take photos with as many of the below items as you can. Each photo should be a selfie with the whole team and the item in the list. Enter the time below that everyone should be done by. At that time everybody will meet up at Red Robins. Loser buys everyone milkshakes!';
            }
        }

        // Check hunt status
        function checkHuntStatus() {
            if (endTime && endTime <= new Date()) {
                showHuntEnded();
            }
            updateInstructions();
        }

        // Render items
        function renderItems() {
            const container = document.getElementById('scavengerList');
            // Clear existing items and sections
            container.innerHTML = '<h2>Find & Photograph:</h2>';
            
            const huntActive = endTime && endTime > new Date();
            const activeItems = [];
            const finishedItems = [];
            
            // Separate items into active and finished
            items.forEach(item => {
                const hasPhoto = hasTeamPhotoForItem(item.id);
                if (hasPhoto) {
                    finishedItems.push(item);
                } else {
                    activeItems.push(item);
                }
            });
            
            // Render active items
            activeItems.forEach(item => {
                const photos = getPhotosForItem(item.id);
                const itemDiv = document.createElement('div');
                itemDiv.className = 'item';
                itemDiv.innerHTML = `
                    <div class="item-info">
                        <div class="item-title">${item.title}</div>
                        <div class="item-description">${item.description}</div>
                    </div>
                    <div class="item-photos">
                        ${photos.map(photo => `
                            <img src="${photo.data}" alt="Photo" class="photo-preview ${photo.team}" onclick="viewPhoto('${item.id}', '${photo.id}')" onerror="handleImageError('${photo.id}', '${item.id}', '${photo.team}')" />
                        `).join('')}
                        ${huntActive ? `
                            <div>
                                <input type="file" accept="image/*" capture="environment" class="file-input" id="file-${item.id}" onchange="uploadPhoto('${item.id}', this)" />
                                <button class="upload-btn" onclick="document.getElementById('file-${item.id}').click()">ðŸ“· Add Photo</button>
                            </div>
                        ` : ''}
                    </div>
                `;
                container.appendChild(itemDiv);
            });
            
            // Render finished items section if there are any
            if (finishedItems.length > 0) {
                const finishedSection = document.createElement('div');
                finishedSection.className = 'finished-section';
                finishedSection.innerHTML = '<h2>âœ… Finished</h2>';
                
                finishedItems.forEach(item => {
                    const photos = getPhotosForItem(item.id);
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'item finished';
                    const buttonText = huntActive ? 'ðŸ“· Change Photo' : '';
                    itemDiv.innerHTML = `
                        <div class="item-info">
                            <div class="item-title">${item.title}</div>
                            <div class="item-description">${item.description}</div>
                        </div>
                        <div class="item-photos">
                            ${photos.map(photo => `
                                <img src="${photo.data}" alt="Photo" class="photo-preview ${photo.team}" onclick="viewPhoto('${item.id}', '${photo.id}')" />
                            `).join('')}
                            ${huntActive ? `
                                <div>
                                    <input type="file" accept="image/*" capture="environment" class="file-input" id="file-${item.id}" onchange="uploadPhoto('${item.id}', this)" />
                                    <button class="upload-btn" onclick="document.getElementById('file-${item.id}').click()">${buttonText}</button>
                                </div>
                            ` : ''}
                        </div>
                    `;
                    finishedSection.appendChild(itemDiv);
                });
                
                container.appendChild(finishedSection);
            }
        }

        // Select team globally and update theme
        function selectTeamGlobal(team, save = true) {
            selectedTeam = team;
            
            // Hide selector buttons and show title
            document.getElementById('teamSelectorButtons').style.display = 'none';
            const titleDisplay = document.getElementById('teamTitleDisplay');
            titleDisplay.classList.add('show');
            titleDisplay.classList.remove('mom', 'dad');
            titleDisplay.classList.add(team);
            
            if (team === 'mom') {
                document.getElementById('teamTitleText').textContent = 'ðŸ‘© Mom Team';
                document.body.className = 'theme-mom';
            } else {
                document.getElementById('teamTitleText').textContent = 'ðŸ‘¨ Dad Team';
                document.body.className = 'theme-dad';
            }
            
            // Save to localStorage
            if (save) {
                localStorage.setItem('selectedTeam', team);
            }
            
            // Re-render items to reflect team change
            renderItems();
            if (endTime && endTime <= new Date()) {
                renderGallery();
            }
        }

        // Show team selector buttons again
        function showTeamSelector() {
            document.getElementById('teamSelectorButtons').style.display = 'flex';
            document.getElementById('teamTitleDisplay').classList.remove('show');
            document.body.className = ''; // Reset to neutral theme
        }

        // Convert image file to JPEG for compatibility (handles HEIF/HEIC and ensures JPEG output)
        async function convertToJpeg(file) {
            // Check if already JPEG - if so, return as-is (no need to re-encode)
            if (file.type === 'image/jpeg' || file.type === 'image/jpg') {
                console.log('File is already JPEG, using as-is');
                return file;
            }
            
            // Always convert other formats to JPEG for maximum compatibility
            // This ensures HEIF/HEIC files work on all platforms
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        // Create canvas and draw image
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        
                        // Convert to JPEG blob
                        canvas.toBlob(function(blob) {
                            if (blob) {
                                // Create a new File object with JPEG extension
                                const jpegFile = new File([blob], file.name.replace(/\.[^/.]+$/, '') + '.jpg', {
                                    type: 'image/jpeg',
                                    lastModified: Date.now()
                                });
                                console.log('Converted image to JPEG:', jpegFile.name, jpegFile.type);
                                resolve(jpegFile);
                            } else {
                                reject(new Error('Failed to convert image to JPEG'));
                            }
                        }, 'image/jpeg', 0.92); // 0.92 quality
                    };
                    img.onerror = function(error) {
                        // If image can't be loaded (e.g., HEIF that browser can't decode)
                        console.error('Could not load image for conversion. File type:', file.type, 'File name:', file.name);
                        reject(new Error('Browser cannot read this image format (HEIF/HEIC not supported). Please take a new photo with the camera or select a JPEG/PNG image.'));
                    };
                    img.src = e.target.result;
                };
                reader.onerror = function() {
                    reject(new Error('Failed to read file'));
                };
                reader.readAsDataURL(file);
            });
        }

        // Upload photo
        async function uploadPhoto(itemId, input) {
            const file = input.files[0];
            if (!file) return;

            const photoId = Date.now().toString();
            const timestamp = new Date().toISOString();
            
            // Always convert to JPEG for compatibility (handles HEIF/HEIC and ensures cross-platform compatibility)
            let fileToUpload;
            try {
                console.log('Converting image:', file.name, file.type);
                fileToUpload = await convertToJpeg(file);
                console.log('Conversion successful:', fileToUpload.name, fileToUpload.type);
            } catch (error) {
                console.error('Error converting image:', error);
                alert('This image format cannot be processed. Please take a new photo with the camera or select a JPEG/PNG image.');
                // Reset the input
                input.value = '';
                return;
            }

            if (useFirebase && firebaseStorage) {
                // Upload to Firebase Storage
                try {
                    const storageRef = firebaseStorage.ref();
                    const photoRef = storageRef.child(`photos/${photoId}_${fileToUpload.name}`);
                    
                    // Show upload progress
                    const uploadBtn = input.nextElementSibling;
                    const originalText = uploadBtn.textContent;
                    uploadBtn.textContent = 'â³ Uploading...';
                    uploadBtn.disabled = true;

                    const snapshot = await photoRef.put(fileToUpload);
                    const downloadURL = await snapshot.ref.getDownloadURL();

                    const photo = {
                        id: photoId,
                        itemId: itemId,
                        team: selectedTeam,
                        url: downloadURL, // Store URL instead of base64
                        data: downloadURL, // For compatibility
                        timestamp: timestamp,
                        filename: fileToUpload.name
                    };

                    const photos = getPhotos();
                    photos.push(photo);
                    await savePhotos(photos);
                    
                    uploadBtn.textContent = originalText;
                    uploadBtn.disabled = false;
                    
                    // Re-render items
                    renderItems();
                    updateScores();
                } catch (error) {
                    console.error('Upload error:', error);
                    alert('Failed to upload photo. Please try again.');
                    const uploadBtn = input.nextElementSibling;
                    uploadBtn.textContent = 'ðŸ“· Add Photo';
                    uploadBtn.disabled = false;
                }
            } else {
                // Fallback to localStorage
                const reader = new FileReader();
                reader.onload = function(e) {
                    const photo = {
                        id: photoId,
                        itemId: itemId,
                        team: selectedTeam,
                        data: e.target.result,
                        timestamp: timestamp
                    };

                    const photos = getPhotos();
                    photos.push(photo);
                    savePhotos(photos);
                    
                    // Re-render items
                    renderItems();
                    updateScores();
                };
                reader.readAsDataURL(fileToUpload);
            }
        }

        // Load photos from Firebase Storage
        async function loadPhotosFromFirebase() {
            try {
                const metadataRef = firebaseStorage.ref().child('photos/metadata.json');
                
                // Try using getBytes first (avoids CORS issues) if available
                let photos;
                if (typeof metadataRef.getBytes === 'function') {
                    try {
                        const bytes = await metadataRef.getBytes();
                        const text = new TextDecoder('utf-8').decode(bytes);
                        photos = JSON.parse(text);
                        console.log('Loaded photos from Firebase using getBytes');
                    } catch (bytesError) {
                        console.log('getBytes failed, trying download URL method:', bytesError);
                        // Fall through to download URL method
                    }
                }
                
                // Fallback to download URL method if getBytes not available or failed
                if (!photos) {
                    try {
                        const url = await metadataRef.getDownloadURL();
                        // Use XMLHttpRequest instead of fetch to avoid CORS preflight
                        photos = await new Promise((resolve, reject) => {
                            const xhr = new XMLHttpRequest();
                            xhr.open('GET', url, true);
                            xhr.onload = function() {
                                if (xhr.status === 200) {
                                    try {
                                        resolve(JSON.parse(xhr.responseText));
                                    } catch (e) {
                                        reject(new Error('Failed to parse JSON: ' + e.message));
                                    }
                                } else {
                                    reject(new Error(`HTTP error! status: ${xhr.status}`));
                                }
                            };
                            xhr.onerror = function() {
                                reject(new Error('Network error'));
                            };
                            xhr.send();
                        });
                        console.log('Loaded photos from Firebase using download URL');
                    } catch (urlError) {
                        throw urlError;
                    }
                }
                
                // Merge with local photos (Firebase takes precedence for conflicts)
                const localPhotos = getPhotosLocal();
                const mergedPhotos = [...photos];
                
                // Add local photos that aren't in Firebase
                localPhotos.forEach(localPhoto => {
                    if (!mergedPhotos.find(p => p.id === localPhoto.id)) {
                        mergedPhotos.push(localPhoto);
                    }
                });
                
                savePhotosLocal(mergedPhotos);
                return true;
            } catch (error) {
                // Metadata file doesn't exist yet, that's okay
                console.log('No existing photos in Firebase, starting fresh');
                return false;
            }
        }

        // Sync photos from Firebase (for multi-device sync)
        async function syncPhotosFromFirebase() {
            if (!useFirebase || !firebaseStorage) return;
            
            try {
                const metadataRef = firebaseStorage.ref().child('photos/metadata.json');
                const url = await metadataRef.getDownloadURL();
                const response = await fetch(url);
                const firebasePhotos = await response.json();
                
                const localPhotos = getPhotosLocal();
                let needsUpdate = false;
                
                // Check if Firebase has photos we don't have locally
                firebasePhotos.forEach(fbPhoto => {
                    if (!localPhotos.find(p => p.id === fbPhoto.id)) {
                        localPhotos.push(fbPhoto);
                        needsUpdate = true;
                    }
                });
                
                if (needsUpdate) {
                    savePhotosLocal(localPhotos);
                    // Re-render items to show new photos
                    renderItems();
                    updateScores();
                }
            } catch (error) {
                // File doesn't exist or error, that's okay
            }
        }

        // Save photos metadata to Firebase
        async function savePhotosToFirebase(photos) {
            if (!useFirebase || !firebaseStorage) return;
            
            try {
                const metadataRef = firebaseStorage.ref().child('photos/metadata.json');
                const metadataJson = JSON.stringify(photos);
                const blob = new Blob([metadataJson], { type: 'application/json' });
                await metadataRef.put(blob);
            } catch (error) {
                console.error('Error saving metadata to Firebase:', error);
            }
        }

        // Get photos (from localStorage)
        function getPhotos() {
            return getPhotosLocal();
        }

        // Get photos from localStorage
        function getPhotosLocal() {
            const saved = localStorage.getItem('huntPhotos');
            return saved ? JSON.parse(saved) : [];
        }

        // Save photos (to both localStorage and Firebase)
        async function savePhotos(photos) {
            savePhotosLocal(photos);
            if (useFirebase && firebaseStorage) {
                await savePhotosToFirebase(photos);
            }
        }

        // Save photos to localStorage only
        function savePhotosLocal(photos) {
            localStorage.setItem('huntPhotos', JSON.stringify(photos));
        }

        // Get photos for item (filtered by team during hunt)
        function getPhotosForItem(itemId) {
            const allPhotos = getPhotos().filter(p => p.itemId === itemId);
            const huntActive = endTime && endTime > new Date();
            
            // During hunt, only show current team's photos
            if (huntActive) {
                return allPhotos.filter(p => p.team === selectedTeam);
            }
            
            // After hunt, show all photos
            return allPhotos;
        }

        // Check if current team has a photo for an item
        function hasTeamPhotoForItem(itemId) {
            const allPhotos = getPhotos().filter(p => p.itemId === itemId && p.team === selectedTeam);
            return allPhotos.length > 0;
        }

        // Update scores
        function updateScores() {
            const photos = getPhotos();
            const momCount = photos.filter(p => p.team === 'mom').length;
            const dadCount = photos.filter(p => p.team === 'dad').length;
            
            document.getElementById('momScore').textContent = momCount;
            document.getElementById('dadScore').textContent = dadCount;
            
            // Show winner celebration and milkshake message
            const winnerEl = document.getElementById('winnerCelebration');
            const milkshakeEl = document.getElementById('milkshakeMessage');
            
            if (momCount > dadCount) {
                winnerEl.textContent = 'ðŸŽ‰ Mom Team Wins! ðŸŽ‰';
                winnerEl.className = 'winner-celebration mom';
                milkshakeEl.textContent = 'ðŸ‘¨ Dad Team, time to buy the milkshakes!';
            } else if (dadCount > momCount) {
                winnerEl.textContent = 'ðŸŽ‰ Dad Team Wins! ðŸŽ‰';
                winnerEl.className = 'winner-celebration dad';
                milkshakeEl.textContent = 'ðŸ‘© Mom Team, time to buy the milkshakes!';
            } else if (momCount === dadCount && momCount > 0) {
                winnerEl.textContent = 'ðŸ¤ It\'s a Tie! ðŸ¤';
                winnerEl.className = 'winner-celebration';
                milkshakeEl.textContent = 'Everyone buys their own milkshakes!';
            } else {
                winnerEl.textContent = '';
                winnerEl.className = 'winner-celebration';
                milkshakeEl.textContent = '';
            }
        }

        // Render gallery
        function renderGallery() {
            const container = document.getElementById('photosGallery');
            const allPhotos = getPhotos();
            const huntActive = endTime && endTime > new Date();
            
            // During hunt, only show current team's photos
            const photos = huntActive ? allPhotos.filter(p => p.team === selectedTeam) : allPhotos;
            
            if (huntActive && photos.length === 0) {
                container.innerHTML = '<h2>Your Photos</h2><p>No photos uploaded yet.</p>';
                return;
            }

            // After hunt, show all items with photos side by side
            if (!huntActive) {
                let html = '<h2>Results</h2>';
                
                items.forEach(item => {
                    const itemPhotos = photos.filter(p => p.itemId === item.id);
                    const momPhotos = itemPhotos.filter(p => p.team === 'mom');
                    const dadPhotos = itemPhotos.filter(p => p.team === 'dad');
                    
                    html += `
                        <div class="photo-item-group">
                            <div class="photo-item-group-title">${item.title}</div>
                            <div class="photo-item-group-photos">
                    `;
                    
                    // Show mom team photo if exists
                    if (momPhotos.length > 0) {
                        html += `
                            <div class="photo-item-group-photo mom">
                                <img src="${momPhotos[0].data}" alt="${item.title} - Mom Team" onerror="handleImageError('${momPhotos[0].id}', '${item.id}', 'mom')" />
                                <div class="photo-item-group-photo-label mom">ðŸ‘© Mom Team</div>
                            </div>
                        `;
                    } else {
                        html += `
                            <div class="photo-item-group-photo">
                                <div class="photo-item-group-no-photos">ðŸ‘© Mom Team - No photo</div>
                            </div>
                        `;
                    }
                    
                    // Show dad team photo if exists
                    if (dadPhotos.length > 0) {
                        html += `
                            <div class="photo-item-group-photo dad">
                                <img src="${dadPhotos[0].data}" alt="${item.title} - Dad Team" onerror="handleImageError('${dadPhotos[0].id}', '${item.id}', 'dad')" />
                                <div class="photo-item-group-photo-label dad">ðŸ‘¨ Dad Team</div>
                            </div>
                        `;
                    } else {
                        html += `
                            <div class="photo-item-group-photo">
                                <div class="photo-item-group-no-photos">ðŸ‘¨ Dad Team - No photo</div>
                            </div>
                        `;
                    }
                    
                    html += `
                            </div>
                        </div>
                    `;
                });
                
                container.innerHTML = html;
            } else {
                // During hunt, show simple list
                const title = '<h2>Your Photos</h2>';
                let html = title;
                
                items.forEach(item => {
                    const itemPhotos = photos.filter(p => p.itemId === item.id);
                    if (itemPhotos.length > 0) {
                        itemPhotos.forEach(photo => {
                            html += `
                                <div class="photo-item">
                                    <div class="photo-item-header">
                                        <div class="photo-item-title">${item.title}</div>
                                        <div class="photo-item-team ${photo.team}">${photo.team === 'mom' ? 'ðŸ‘© Mom Team' : 'ðŸ‘¨ Dad Team'}</div>
                                    </div>
                                    <img src="${photo.data}" alt="${item.title}" class="photo-item-image" onerror="handleImageError('${photo.id}', '${item.id}', '${photo.team}')" />
                                </div>
                            `;
                        });
                    }
                });
                
                container.innerHTML = html;
            }
        }

        // View photo (placeholder for future modal)
        function viewPhoto(itemId, photoId) {
            // Could add a modal here to view full-size photo
            console.log('View photo:', itemId, photoId);
        }

        // Handle broken image - remove from cache and re-render
        async function handleImageError(photoId, itemId, team) {
            console.log('Image failed to load, removing from cache:', photoId);
            const photos = getPhotos();
            const filteredPhotos = photos.filter(p => p.id !== photoId);
            await savePhotos(filteredPhotos);
            
            // Re-render to update display
            renderItems();
            if (endTime && endTime <= new Date()) {
                renderGallery();
            }
            updateScores();
        }

        // Clear hunt - archives photos and resets timer
        async function clearHunt() {
            if (!confirm('Are you sure you want to clear the hunt? Photos will be archived and the timer will be reset.')) {
                return;
            }

            // Stop countdown and sync
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            if (endTimeSyncInterval) {
                clearInterval(endTimeSyncInterval);
                endTimeSyncInterval = null;
            }

            // Save endTime for archive folder name before clearing
            const huntEndTime = endTime;
            
            // Clear end time - do this first to prevent sync from restoring it
            endTime = null;
            localStorage.removeItem('huntEndTime');

            // Clear photos from localStorage (they're archived in Firebase)
            localStorage.removeItem('huntPhotos');

            // Clear data from Firebase Storage
            if (useFirebase && firebaseStorage) {
                try {
                    // Clear end time FIRST to prevent sync from restoring it
                    const endTimeRef = firebaseStorage.ref().child('huntEndTime.json');
                    let deleteSuccess = false;
                    
                    // Try to delete the file
                    try {
                        await endTimeRef.delete();
                        console.log('Deleted huntEndTime.json from Firebase');
                        deleteSuccess = true;
                    } catch (error) {
                        // Only ignore if file doesn't exist, log other errors
                        if (error.code === 'storage/object-not-found' || 
                            error.code === 'storage/404' ||
                            (error.message && (error.message.includes('404') || error.message.includes('object-not-found')))) {
                            console.log('huntEndTime.json does not exist in Firebase (already cleared)');
                            deleteSuccess = true; // Consider it successful if file doesn't exist
                        } else {
                            console.error('Error deleting huntEndTime.json from Firebase:', error);
                            console.log('Attempting to overwrite with null instead...');
                        }
                    }
                    
                    // If delete failed, overwrite with null to ensure it's cleared
                    if (!deleteSuccess) {
                        try {
                            const emptyData = { endTime: null };
                            const blob = new Blob([JSON.stringify(emptyData)], { type: 'application/json' });
                            await endTimeRef.put(blob);
                            console.log('Overwrote huntEndTime.json with null in Firebase');
                        } catch (overwriteError) {
                            console.error('Error overwriting huntEndTime.json:', overwriteError);
                        }
                    }
                    
                    // Archive photos instead of deleting them
                    if (huntEndTime) {
                        // Create archive folder name from hunt end time
                        const archiveFolderName = huntEndTime.toISOString().replace(/[:.]/g, '-').replace('T', '_').substring(0, 19);
                        const archiveRef = firebaseStorage.ref().child(`archived/${archiveFolderName}`);
                        
                        const photosRef = firebaseStorage.ref().child('photos');
                        const listResult = await photosRef.listAll();
                        
                        // Move all files (photos and metadata) to archive folder
                        const movePromises = listResult.items.map(async (item) => {
                            const fileName = item.name;
                            try {
                                // Copy to archive folder
                                const archiveFileRef = archiveRef.child(fileName);
                                
                                // Download the file
                                const url = await item.getDownloadURL();
                                const response = await fetch(url);
                                const blob = await response.blob();
                                
                                // Upload to archive folder
                                await archiveFileRef.put(blob);
                                console.log(`Uploaded ${fileName} to archive`);
                                
                                // Delete from original location - do this separately with better error handling
                                try {
                                    await item.delete();
                                    console.log(`Deleted ${fileName} from original location`);
                                } catch (deleteError) {
                                    console.error(`Failed to delete ${fileName} from original location:`, deleteError);
                                    // Try to delete using the full path as fallback
                                    try {
                                        const originalRef = photosRef.child(fileName);
                                        await originalRef.delete();
                                        console.log(`Deleted ${fileName} using fallback method`);
                                    } catch (fallbackError) {
                                        console.error(`Fallback delete also failed for ${fileName}:`, fallbackError);
                                        throw deleteError; // Re-throw to be caught by outer catch
                                    }
                                }
                                
                                console.log(`Successfully archived ${fileName} to archived/${archiveFolderName}`);
                            } catch (error) {
                                console.error(`Error archiving ${fileName}:`, error);
                                // Don't throw - continue with other files even if one fails
                            }
                        });
                        
                        await Promise.all(movePromises);
                        
                        // Double-check: try to delete any remaining files
                        try {
                            const remainingList = await photosRef.listAll();
                            if (remainingList.items.length > 0) {
                                console.log(`Found ${remainingList.items.length} remaining files, attempting cleanup...`);
                                const cleanupPromises = remainingList.items.map(async (item) => {
                                    try {
                                        await item.delete();
                                        console.log(`Cleaned up remaining file: ${item.name}`);
                                    } catch (cleanupError) {
                                        console.error(`Failed to cleanup ${item.name}:`, cleanupError);
                                    }
                                });
                                await Promise.all(cleanupPromises);
                            }
                        } catch (cleanupError) {
                            console.error('Error during cleanup:', cleanupError);
                        }
                        
                        console.log(`Archived all photos and metadata to archived/${archiveFolderName}`);
                    } else {
                        // If no endTime, just delete photos (shouldn't happen, but safety fallback)
                        const photosRef = firebaseStorage.ref().child('photos');
                        const listResult = await photosRef.listAll();
                        const deletePromises = listResult.items.map(item => item.delete());
                        await Promise.all(deletePromises);
                        console.log('Cleared photos (no endTime to create archive)');
                    }
                    
                    console.log('Cleared data from Firebase Storage');
                } catch (error) {
                    console.error('Error clearing Firebase Storage:', error);
                }
            }

            // Reset UI
            document.getElementById('timeInputGroup').style.display = 'flex';
            document.getElementById('countdown').classList.remove('show');
            document.getElementById('huntEnded').classList.remove('show');
            document.getElementById('scoresSection').classList.remove('show');
            document.getElementById('photosGallery').classList.remove('show');
            document.getElementById('scavengerList').style.display = 'block';
            document.getElementById('endTime').value = '';

            // Reset instructions
            updateInstructions();

            // Re-render items
            renderItems();
            updateScores();
        }

        // Initialize on load
        init();
    </script>
</body>
</html>
